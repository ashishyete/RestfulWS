const jsonString = '{"Scenarios": {"ONG": [{"S_no":1,"name": "John", "age": 30, "city": "New York"},{"S_no":2,"name": "Jane", "age": 25, "city": "Los Angeles"},{"S_no":3,"name": "Bob", "age": 40, "city": "Chicago"}]}}';

try {
  const jsonObject = JSON.parse(jsonString);
  const ongArray = jsonObject.Scenarios.ONG;

  console.log(ongArray); // This will print the entire array of objects
} catch (error) {
  console.error("Error parsing JSON:", error);
}


import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-json-display',
  template: `
    <div *ngFor="let keyValue of keyValues">
      <strong>{{ keyValue.key }}:</strong> {{ keyValue.value }}
    </div>
  `,
})
export class JsonDisplayComponent implements OnInit {
  keyValues: { key: string; value: any }[] = [];

  ngOnInit() {
    const jsonString = `
      {
        "results": {
          "premiums": {
            "premium_type": ["REG"],
            "monthly_premium": ["(coverage/1000)*0.0996"]
          }
        }
      }
    `;

    const jsonObject = JSON.parse(jsonString).results;

    for (const key in jsonObject) {
      const value = jsonObject[key];
      this.keyValues.push({ key: key, value: value });
    }
  }
}



========================

const express = require('express');
const router = express.Router();

// Define your route handler function
router.get('/yourRoute', async (req, res) => {
  try {
    // Step 1: Get error records
    const errorRecords = await getErrorRecords();
    
    if (errorRecords.length === 0) {
      console.log("No Error records found");
      return res.status(200).send("No Error records found");
    }
    
    // Step 2: Log in and get JWT
    const token_jwt = await loginJwt();

    // Step 3: Get beta_id details
    const responseData = await getBetaIdDetails(errorRecords);

    // Step 4: Call API for each record
    for (const record of responseData) {
      await callApi(record);
    }

    // Respond with success message
    res.status(200).send("Success");
  } catch (error) {
    console.error("Error:", error);
    res.status(500).send("Internal Server Error");
  }
});

// Define your database queries, API calls, and other functions here
async function getErrorRecords() {
  // Implement your database query logic here
  // Return the error records as an array
  return [];
}

async function loginJwt() {
  // Implement your API call to get JWT here
  // Return the JWT as a string
  return "your_jwt_here";
}

async function getBetaIdDetails(errorRecords) {
  // Implement your database query logic here to fetch beta_id details
  // Map the data to the required format and return an array of responseData
  return [];
}

async function callApi(record) {
  // Implement your API call logic here for each record
  // Check the response and handle errors accordingly
  // You can use libraries like Axios for API calls
  // Example:
  // const response = await axios.post(apiUrl, record);
  // if (response.status === 201 || response.status === 200) {
  //   console.log("Success");
  // } else {
  //   console.error("Error:", response.statusText);
  // }
}

module.exports = router;

========================================

async function getBetaIdDetails(errorRecords) {
  const responseData = [];

  for (const errorRecord of errorRecords) {
    const { client_id, client_type, org_id, status } = errorRecord;

    // Implement your database query logic to fetch beta_id details
    // For example, assuming you have a function fetchBetaIdDetailsByOrgId
    const betaIdDetails = await fetchBetaIdDetailsByOrgId(org_id);

    if (betaIdDetails) {
      const { beta_id, first_name, last_name } = betaIdDetails;

      // Create a payload object for this error record
      const payload = {
        beta_id: beta_id,
        first_name: first_name,
        last_name: last_name,
        client_id: client_id,
        org_id: org_id,
        client_type: client_type,
        status: status,
      };

      // Push the payload object into the responseData array
      responseData.push(payload);
    }
  }

  return responseData;
}



WITH dynamic_query AS (
  SELECT DISTINCT proj_nm, team_nm
  FROM your_dynamic_query_table_or_source
)

SELECT t.*
FROM t_main t
LEFT JOIN dynamic_query dq ON t.proj_nm = dq.proj_nm AND t.team_nm = dq.team_nm
WHERE dq.proj_nm IS NULL AND dq.team_nm IS NULL;


<div class="accordion" id="projectAccordion">
  <div *ngFor="let project of responseData.data.data" class="accordion-item">
    <h2 class="accordion-header" id="heading{{ project.proj_nm }}">
      <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse{{ project.proj_nm }}" aria-expanded="true" aria-controls="collapse{{ project.proj_nm }}">
        {{ project.proj_nm }}
      </button>
    </h2>
    <div id="collapse{{ project.proj_nm }}" class="accordion-collapse collapse" aria-labelledby="heading{{ project.proj_nm }}" data-bs-parent="#projectAccordion">
      <div class="accordion-body">
        <ul>
          <li *ngFor="let category of project.categories">
            {{ category.cat_nm }}: {{ category.flg }}
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>



<div class="accordion accordion-flush" id="projectAccordion">
  <div *ngFor="let project of responseData.data" class="accordion-item">
    <h2 class="accordion-header" id="heading{{ project.proj_nm }}">
      <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapse{{ project.proj_nm }}" aria-expanded="true" aria-controls="collapse{{ project.proj_nm }}">
        {{ project.proj_nm }}
      </button>
    </h2>
    <div id="collapse{{ project.proj_nm }}" class="accordion-collapse collapse" aria-labelledby="heading{{ project.proj_nm }}" data-bs-parent="#projectAccordion">
      <div class="accordion-body">
        <ul>
          <li *ngFor="let category of project.categories">
            {{ category.cat_nm }}: {{ category.flg }}
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>


#!/bin/bash

# Define PostgreSQL connection parameters for MirrorDB
MIRROR_DB_HOST="mirror_db_host"
MIRROR_DB_PORT="mirror_db_port"
MIRROR_DB_NAME="MirrorDB"
MIRROR_DB_USER="mirror_db_user"
MIRROR_DB_PASSWORD="mirror_db_password"

# Define PostgreSQL connection parameters for GoldDB
GOLD_DB_HOST="gold_db_host"
GOLD_DB_PORT="gold_db_port"
GOLD_DB_NAME="GoldDB"
GOLD_DB_USER="gold_db_user"
GOLD_DB_PASSWORD="gold_db_password"

# Table to copy
TABLE_NAME="t_demo"

# Dump data from the MirrorDB (without table creation)
PGPASSWORD="$MIRROR_DB_PASSWORD" pg_dump -h $MIRROR_DB_HOST -p $MIRROR_DB_PORT -U $MIRROR_DB_USER -W -a -v -f $TABLE_NAME.dump $MIRROR_DB_NAME --table=$TABLE_NAME

# Truncate the destination table in GoldDB
psql -h $GOLD_DB_HOST -p $GOLD_DB_PORT -U $GOLD_DB_USER -W -d $GOLD_DB_NAME -c "TRUNCATE $TABLE_NAME RESTART IDENTITY;"

# Restore data to the GoldDB (without table creation)
PGPASSWORD="$GOLD_DB_PASSWORD" pg_restore -h $GOLD_DB_HOST -p $GOLD_DB_PORT -U $GOLD_DB_USER --data-only -v $TABLE_NAME.dump -d $GOLD_DB_NAME

# Remove the dump file
rm $TABLE_NAME.dump

echo "Data copy from MirrorDB to GoldDB for table $TABLE_NAME completed."






